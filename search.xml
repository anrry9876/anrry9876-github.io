<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[淺談 SQL 與 NoSQL]]></title>
      <url>http://blog.30cm.net/2017/04/21/%E6%B7%BA%E8%AB%87NoSQL/</url>
      <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>為了完成我在2017年的年度挑戰 =&gt; 製作智慧語音助手，所以需要自製一個聊天機器人 <b> ChatBot </b> ，而我所選的聊天機器人是配合 Python 使用的<a href="https://github.com/gunthercox/ChatterBot" target="_blank" rel="external">Chatterbot</a>  ，為了使機器人可以接受大量資料的訓練，而需要接觸到  MongoDB ，那廢話不在多說，我們就先從 NoSQL 開始談起吧！</p>
<h1 id="關於-nosql"><a href="#關於-NoSQL" class="headerlink" title="關於 NoSQL"></a>關於 NoSQL</h1><h2 id="觀念"><a href="#觀念" class="headerlink" title="# 觀念"></a># 觀念</h2><blockquote>
<p>近幾年，資訊產業無論從 AI 的運用到雲端計算 (Cloud Computing) 、大數據（Big Data）、IoT 等新技術，都脫離不了資料量大的問題，而「NoSQL」便是伴隨著這個主題所產生的技術主題。</p>
</blockquote>
<p>Q：為何 NoSQL 可以在關聯式資料庫已經非常普及的情況下異軍突起？</p>
<blockquote>
<p><b>Ans </b>: 首先要了解 <strong>SQL 與 NoSQL 在本質上的差異，SQL 的特性，是在同一台機器上面，解決所有的事情，而 NoSQL 是可以利用非常多台不同的電腦來解決問題</strong>，有了這個基本的了解之後，我們就來舉個簡單的例子說明一下！</p>
<p>誠如Facebook、Google、Twitter這些國外大型網站，這些網站擁有巨量使用者，而每個使用者都會貢獻自己的資料，且不斷成長。為了滿足資料成長的擴充需求，傳統的商用關聯式資料庫借助資料庫叢集技術才能解決，然而這就得投資高額的軟硬體擴充經費。網站業者為了解決如TB等級甚至是PB等級的巨量資料儲存和擴充問題，開始研發各種建置成本較低的分散式開源資料庫。</p>
</blockquote>
<hr>
<h3 id="sql-與-nosql-的比較"><a href="#SQL-與-NoSQL-的比較" class="headerlink" title="SQL 與 NoSQL 的比較"></a>SQL 與 NoSQL 的比較</h3><p>從上述的例子當中，我們可以具體的看出來，巨量資料對技術提出了更多的需求，主要體現在下面這四個方面：</p>
<ol>
<li>低延遲的讀寫速度：應用快速地反應能極大地提升用戶的滿意度</li>
<li>支援巨量的資料與流量：對於搜尋這樣的大型應用程式而言，需要使用PB級的資料量</li>
<li>分散式的管理</li>
<li>低廉的成本</li>
</ol>
<p>我們大概可以整理出在巨量資料的時代，資料庫上使用的差異，所以就做了一張表格，讓大家看看這兩者的差別</p>
<p><img src="https://lh3.googleusercontent.com/-LM0pG8qNd98/WPnF1ab01hI/AAAAAAAAADQ/GZyuFkJof0gni7OHQnZc20eaBPwxcZeWQCLcB/s0/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2017-04-21+%25E4%25B8%258B%25E5%258D%25884.39.51.png" alt="enter image description here" title="螢幕快照 2017-04-21 下午4.39.51.png"></p>
<h2 id="定義"><a href="#定義" class="headerlink" title="#定義"></a>#定義</h2><p>在我第一次看到 <strong>NoSQL</strong>的時候，我的直覺反應是不使用 SQL來作為儲存的工具，其實，經過瞭解之後比較像是 Not Only SQL 來解釋，並不是完全捨棄關聯式資料庫，而是根據處理的資料格式來決定什麼時候使用關聯式資料庫，什麼時候使用非關聯式資料庫。NoSQL也就是透過 SQL 的 API 來存取這一種類型的資料庫，以下則是摘錄《<a href="http://nosql-database.org/" target="_blank" rel="external">nosql-database.org</a>》網站對「NoSQL」的定義：</p>
<blockquote>
<p>Next Generation Databases mostly addressing some of the points: being non-relational, distributed, open-source and horizontally scalable. </p>
</blockquote>
<h2 id="特徵"><a href="#特徵" class="headerlink" title="#特徵"></a>#特徵</h2><ul>
<li><p><span style=" border: 0px;color: #fff;background: #f44336;border: 1px solid #f44336;border-radius: 4px;padding: 2px 5px;margin: 0 1px;">Schema-less</span><br>有著類似 Table 的資料結構，但不需預先定義 schema。<br>每一筆記錄的欄位數量與結構也可以不一樣。<br>紀錄的內容與限制條件主要由應用程式來控管。</p>
</li>
<li><p><span style=" border: 0px;color: #fff;background: #f44336;border: 1px solid #f44336;border-radius: 4px;padding: 2px 5px;margin: 0 1px;">Shared nothing architecture </span><br>通常採用本地儲存、而非共同儲存設備（如 SAN 或 NAS）。<br>使用一般規格的硬體即可（commodity hardware），故成本也隨之下降。</p>
</li>
<li><p>Elasticity<br>只需增加更多主機，便能立即擴充儲存容量與負載能力，所以不需要有停機時間（downtime）。<br>當新節點加入後，資料庫便會開始分配任務給它。</p>
</li>
<li><p><span style=" border: 0px;color: #fff;background: #f44336;border: 1px solid #f44336;border-radius: 4px;padding: 2px 5px;margin: 0 1px;">Sharding</span><br>不將儲存視為龐大的空間，取而代之的是以「分片」（shard）方式來分割資料集。<br>分片過大時，可採用自動分割方式，或者以程式為每一筆記錄指派所屬的分片ID。</p>
</li>
<li><p><span style=" border: 0px;color: #fff;background: #f44336;border: 1px solid #f44336;border-radius: 4px;padding: 2px 5px;margin: 0 1px;">Asynchronous replication</span><br>相較於 RAID （mirroring / stripping）或同步複製機制，NoSQL DB採用的是非同步的複製。<br>又因為資料不會立即複製，所以某些時候可能發生資料遺失的狀況。<br>此外，也沒有 lock 機制以保護某些特定資料。</p>
</li>
<li><p><span style=" border: 0px;color: #fff;background: #f44336;border: 1px solid #f44336;border-radius: 4px;padding: 2px 5px;margin: 0 1px;">BASE instead of ACID</span><br>由於 NoSQL DB 強調的是效能與可用度，所以「CAP Theorem」會比 RDBMS 的「ACID」更為重要。（注一）</p>
</li>
</ul>
<h2 id="nosql-db-的類型"><a href="#NoSQL-DB-的類型" class="headerlink" title="# NoSQL DB 的類型"></a># NoSQL DB 的類型</h2><h3 id="鍵值儲存-key-value-tuple-store"><a href="#鍵值儲存-Key-Value-Tuple-Store" class="headerlink" title="鍵值儲存 (Key Value / Tuple Store)"></a><strong>鍵值儲存 (Key Value / Tuple Store)</strong></h3><p>這為最常見的 NoSQL 資料庫儲存類型，資料會由一對 key-value的方式儲存，並且根據資料的儲存方式可分為 臨時性、永久性、臨時-永久共存性三種</p>
<ul>
<li><p>臨時性<br>此種方式即為將資料全部儲存在記憶體中，儲存與讀取的速度會變得相當的快，但是只要電源拔除資料就會全部消失 (如Memcached、Redis、Velocity、Tuple space)，這類資料庫改成將資料儲存在記憶體中以提高讀取效率，多是作為快取用途，像是快取常用網頁，加快傳遞網頁的速度以減少讀取硬碟的次數。</p>
</li>
<li><p>永久性<br>與臨時性相反，這類的資料庫將資料儲存在硬碟上，因此資料會永久保存不會因為電源拔除鳩消失，但在進行資料儲存與讀取上勢必要對硬碟進行 I/O 操作，因此在效能上會與臨時性的方式有些差距。</p>
</li>
<li><p>臨時-永久共存性<br>這類的資料庫擷取了臨時與永久性的優點 (如Redis)，透過先將資料全部儲存在記憶體中，以增加讀取/寫入的速度，接下來設定多個門檻 (threshold)，用來決定哪些資料需要寫入到磁碟中，確保資料的永久性，這類型的資料庫特別適合處理陣列類型的資料</p>
</li>
</ul>
<h3 id="文件儲存-document-store"><a href="#文件儲存-Document-Store" class="headerlink" title="文件儲存 (Document Store)"></a><strong>文件儲存 (Document Store)</strong></h3><p>這類型的資料庫有兩個特色：不定義表的結構 以及 可以使用複雜的查詢準則，常見的開源文件資料庫有MongoDB、CouchDB。</p>
<ul>
<li><p>不定義表的結構 (非結構化資料)<br>最常見的非結構化資料就是 HTML 網頁，即使不定義表的結構，也可以像是定義了表結構一樣的使用，像是 <head></head>、<body></body> 中所含有的資料段落行數皆不相同 (有連結、圖片、文字等標籤樹狀結構內容)，且不同網頁的內容都不相同，在現在網頁儲存與搜尋索引大增的情況下，這類型的資料庫是對於儲存網頁內容是相當的方便。</p>
</li>
<li><p>可以使用複雜的查詢準則<br>文件儲存類型的資料庫與鍵值儲存類型不同，可以透過較複雜的查詢準則來取得資料，雖然不具備關聯式資料庫的 交易處理 與 JOIN 處理能力，但處此之外的處理基本上都能夠實現。如 MongoDB 可以在查詢指令中使用 JavaScript 進行查詢，CouchDB 則是除了可以使用Javescript 之外，甚至還提供一套RESTful API，讓應用程式可透過 HTTP 協定進行資料的查詢。</p>
</li>
</ul>
<h3 id="圖學式儲存-graph-database"><a href="#圖學式儲存-Graph-Database" class="headerlink" title="圖學式儲存 (Graph Database)"></a><strong>圖學式儲存 (Graph Database)</strong></h3><p>這類型的資料庫不是指專門處理圖像的資料庫，而是指以圖學架構的概念儲存資料，基本的圖學資料包括了節點（Node）、關係（Relation）和屬性（Property）三種結構，透過樹狀結構、網狀結構的方式，將各節點之間的關係儲存幾來，特別適合用來儲存複雜的資料關係，如社群關係、地理圖資等等。常見的圖學資料庫如Neo4j、InfoGrid、AllegroGrph。</p>
<h3 id="寬列儲存-wide-column-store-column-families"><a href="#寬列儲存-Wide-Column-Store-Column-Families" class="headerlink" title="寬列儲存 (Wide Column Store / Column Families)"></a><strong>寬列儲存 (Wide Column Store / Column Families)</strong></h3><p>這類的資料庫如 Cassandra、Hbase 和 HyperTable，與關聯式資料庫相反，是以列為單位來儲存資料，對大量行少數列進行讀取的情況與對所有特定列進行同時更新的情況有較高的優勢，其儲存資料的方式可以理解成一個三維的鍵值儲存 (Key-Value)，也就是Google 設計的 BigTable 模型，其中資料表內的資料是透過一個行關鍵字 (Row Key)、一個列關鍵字 (Column Key) 及一個時間戳記 (Time Stamp) 進行索引，其對儲存的資料不做任何解析，一律視為字串，實際資料結構的實現需要使用者自行處理。{BigTable儲存邏輯 (row:string, column:string, time:int64) -&gt; string ) }</p>
<hr>
<h3 id="註一"><a href="#註一" class="headerlink" title="# 註一"></a># 註一</h3><p><strong>NoSQL DB 的理論基礎 - CAP &amp; BASE</strong></p>
<ul>
<li><p>Consistency（一致性）<br>一致性是說資料的原子性，這種原子性在傳統 RDBMS 中是透過 Transaction 來保證的，當 Transaction 完成時，無論其是成功還是回滾，資料都會處於一致的狀態。在分散式環境中，一致性是說多個節點的資料是否一致。</p>
</li>
<li><p>Availability（可用性）<br>可用性是說服務能一直保證是可用的狀態，當使用者發出一個請求，服務能在有限時間內返回結果。</p>
</li>
<li><p>Partition Tolerance（分區容錯性）<br>Partition 是指網路的分區。可以這樣理解，一般來說，關鍵的資料和服務都會位於不同的 IDC 機房。</p>
</li>
</ul>
<p><strong>ACID</strong><br>是指資料庫管理系統（DBMS）在寫入或更新資料的過程中，為保證事務（transaction）是正確可靠的，所必須具備的四個特性。<br>在資料庫系統中，一個事務是指：由一系列資料庫操作組成的一個完整的邏輯過程。例如銀行轉帳，從原帳戶扣除金額，以及向目標帳戶添加金額，這兩個資料庫操作的總和，構成一個完整的邏輯過程，不可拆分。這個過程被稱為一個事務，具有ACID特性。</p>
<p>四個特性：</p>
<ul>
<li><p>原子性：<br>一個事務（transaction）中的所有操作，要麼全部完成，要麼全部不完成，不會結束在中間某個環節。事務在執行過程中發生錯誤，會被回滾（Rollback）到事務開始前的狀態，就像這個事務從來沒有執行過一樣。</p>
</li>
<li><p>一致性：<br>在事務開始之前和事務結束以後，資料庫的完整性沒有被破壞。這表示寫入的資料必須完全符合所有的預設規則，這包含資料的精確度、串聯性以及後續資料庫可以自發性地完成預定的工作。</p>
</li>
<li><p>隔離性：<br>資料庫允許多個並發事務同時對其數據進行讀寫和修改的能力，隔離性可以防止多個事務並發執行時由於交叉執行而導致數據的不一致。事務隔離分為不同級別，包括讀未提交（Read uncommitted）、讀提交（read committed）、可重複讀（repeatable read）和串行化（Serializable）。</p>
</li>
<li><p>持久性：<br>事務處理結束後，對數據的修改就是永久的，即便系統故障也不會丟失。</p>
</li>
</ul>
<hr>
<h3 id="結論"><a href="#結論" class="headerlink" title="# 結論"></a># 結論</h3><blockquote>
<p>預先了解非關連式資料庫是如何運作的，才可知己知彼百戰百勝！</p>
</blockquote>
<p>不是只有大量資料的處理才會需要越到非關連式資料庫，了解兩種不同資料庫的特性之後，就可以針對情況來選擇適合的類型，使得資料在處理上更加簡單，</p>
<p><strong><em>下篇將會介紹，Mongo DB !</em></strong></p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Python 淺談多執行緒]]></title>
      <url>http://blog.30cm.net/2017/02/01/Python-%E6%B7%BA%E8%AB%87%E5%A4%9A%E5%9F%B7%E8%A1%8C%E7%B7%92-1/</url>
      <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>多執行緒的應用其實已經行之有年，且寫爬蟲或是自動化的程式時常常會使用到，但在讀 Thread 時常常會與 Process 給搞混，所以為了讓自己更加清楚地瞭解其中的差異，特此紀錄。</p>
<h1 id="thread-與-process-的差異"><a href="#Thread-與-Process-的差異" class="headerlink" title="Thread 與 Process 的差異"></a>Thread 與 Process 的差異</h1><p>一開始接觸的時候很難弄懂 Process 與 Thread 的差異，但我們現在就來介紹這這對兄弟。文中有一些原文，因為翻得不夠好，所以還是原汁原味的呈現。</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><ul>
<li><p>早期電腦系統在一段時間內只允許一個程式執行</p>
</li>
<li><p>今日的電腦系統允許許多程式載入到記憶體中並同時執行</p>
</li>
<li><p>系統需要對不同程式做更嚴謹的控制與區分</p>
</li>
</ul>
<h2 id="什麼是-process-行程"><a href="#什麼是-Process-行程" class="headerlink" title="什麼是 Process (行程) ?"></a>什麼是 Process (行程) ?</h2><p>事情依照時間先後順序組織排列而成，喂～不是那種 <del>行程</del> 拉，是程式的行程，也就是所謂的 Process。</p>
<p><span style=" border: 0px;color: #fff;background: #f44336;border: 1px solid #f44336;border-radius: 4px;padding: 2px 5px;margin: 0 1px;">Process</span> 的定義是「 正在執行的程式 」！</p>
<p>一般而言，程式是人類寫出來叫電腦做事情的一種溝通方式，他是靜止的，存在硬碟當中的，而 <span style=" border: 0px;color: #fff;background: #f44336;border: 1px solid #f44336;border-radius: 4px;padding: 2px 5px;margin: 0 1px;">Process</span> 是指將這段程式載入記憶體當中，然後排入CPU的執行週期當中處理（ 正在 CPU 執行的 Program ）。</p>
<blockquote>
<p>簡單來說，程式是一種死的<span style=" border: 0px;color: #fff;background: #f44336;border: 1px solid #f44336;border-radius: 4px;padding: 2px 5px;margin: 0 1px;">Passive</span> 狀態，行程是活的<span style=" border: 0px;color: #fff;background: #88da5e;border: 1px solid #cef436#88da5e;border-radius: 4px;padding: 2px 5px;margin: 0 1px;">Active</span>狀態, 它具備程式計數器來指明下一個要執行的指令。</p>
</blockquote>
<p>行程在執行時，狀態（state）會改變。所謂狀態，就是指行程目前的動作：</p>
<ol>
<li>新生 (New)            : 行程新產生中。</li>
<li>執行   (Running)      : 正在執行。</li>
<li>等待  ( Wating )        : 等待某事發生，例如等待使用者輸入完成。</li>
<li>就緒  ( Ready )         : 排班中，等待CPU。</li>
<li>結束  ( Terminated ) : 完成執行。</li>
</ol>
<p>各狀態名稱可能隨不同作業系統而相異；任何時間可能有多個行程為等待、就緒，但必定僅有一個行程在執行。</p>
<h2 id="什麼是-thread-執行緒"><a href="#什麼是-Thread-執行緒" class="headerlink" title="什麼是 Thread (執行緒) ?"></a>什麼是 Thread (執行緒) ?</h2><p>一個執行緒是Process中的一個執行流程，一個行程中可以同時包括多個執行緒，CPU會分配時間片段來處理這些子行程，這使得一個程式可以像是同時間處理多個事務。 </p>
<p>多執行緒是指從<span style=" border: 0px;color: #fff;background: #f44336;border: 1px solid #f44336;border-radius: 4px;padding: 2px 5px;margin: 0 1px;">軟體</span>或者<span style=" border: 0px;color: #fff;background: #f44336;border: 1px solid #f44336;border-radius: 4px;padding: 2px 5px;margin: 0 1px;">硬體</span>上實現多個任務併發執行的技術。</p>
<p>軟體多執行緒:</p>
<p>作業系統也可以通過快速的在不同執行緒之間進行切換，由於時間間隔很小，來給用戶造成一種多個執行緒同時運行的假象。</p>
<p>硬體多執行緒:</p>
<p>具有多個處理器的對稱多處理機（SMP）系統，靠硬體執行執行緒切換來獲得多執行緒能力，作業系統不再負責執行緒切換，以 Sun 的UltraSPARCT為例，可能有4個、6個、8個CPU核心，且每個核心最多可同時執掌、處理4個執行緒，最理想狀態下可同時執行32個執行緒。</p>
<p>用一個更清楚的圖例表示：</p>
<p><img src="https://lh3.googleusercontent.com/-IEKzC2RRLZ8/WJAwpH34RcI/AAAAAAAAAGg/74sKHpz8-Mg0rzg0oA-YnbM-bYK_EZ1vwCLcB/s800/%25E6%259C%25AA%25E5%2591%25BD%25E5%2590%258D-1-01.png" alt="enter image description here" title="未命名-1-01.png"></p>
<ul>
<li>Time是時間軸，表示時間的經過</li>
<li>Process 是整隻在執行的程式</li>
<li>Thread 是在程式中執行的分支</li>
</ul>
<hr>
<p>以下為 2017/01/31 的更新內容 </p>
<h1 id="為何要用-thread-執行緒"><a href="#為何要用-Thread-執行緒" class="headerlink" title="為何要用 Thread (執行緒) ?"></a>為何要用 Thread (執行緒) ?</h1><p>很多原因！但我會跟你說我只是想要讓我的硬體可以完全 100 %的被使用到，而不是傻傻地慢慢排隊等前一支程式執行完成！但是也會遇到很多問題 ！例如 Python 的程式庫當中，沒有預設給的多執行緒返回值（Return）的方法、或是煩人地多執行緒的主執行緒阻塞等問題，但也因為他不複雜，只要稍加學習就可以簡單的操作並且應用！所以還是利大於弊拉～～</p>
<h2 id="python-的執行緒函式庫"><a href="#Python-的執行緒函式庫" class="headerlink" title="Python 的執行緒函式庫  ?"></a>Python 的執行緒函式庫  ?</h2><p>Python 的執行緒函式庫無論是Python 2 還是 Python 3  ，都有預設的程式庫分別叫做 Thread 與 Threading ！而我在這邊建議使用 Threading 而不是 thread。 因為，這個程式庫可以提供更高級的執行緒控制，以及可以輸入更多的參數！舉例說明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line"></div><div class="line">def count(i):</div><div class="line">	print &apos;這是一個數字 : &apos;,i</div><div class="line"></div><div class="line">threads = []</div><div class="line"></div><div class="line">for i in range(0,5):</div><div class="line">    threads.append(threading.Thread(target=count, args=(i,))</div><div class="line"></div><div class="line">for t in threads:</div><div class="line">    t.start()</div></pre></td></tr></table></figure></p>
<p>在這一個範例當中，使用了一種很常見的大量呼叫執行緒的方法，在建立一個執行緒的執行列表之後，批次產生 Thread 實例，最後批次使用呼叫 Thread 實例的 Start () 方法啟動執行緒。</p>
<p>在這裡需要注意的地方有：</p>
<ol>
<li>Thread 對象不需要顯示指定的名稱變數，Thread 預設有識別符號，但其實在每個循環當中，每次使用的變數名稱賦予值後啟動也是可行的！</li>
<li>產生Thread 實例的時候args參數一定是元祖為單位！（有注意到 i 後面的逗號嗎？）</li>
</ol>
<h2 id="thread-阻塞情形"><a href="#Thread-阻塞情形" class="headerlink" title="# Thread 阻塞情形"></a># Thread 阻塞情形</h2><h3 id="舉一個簡單的例子來說明何謂阻塞"><a href="#舉一個簡單的例子來說明何謂阻塞？" class="headerlink" title="舉一個簡單的例子來說明何謂阻塞？"></a>舉一個簡單的例子來說明何謂阻塞？</h3><blockquote>
<p>如果您一次產生很多個執行緒，而且每個執行緒都需要比較長的時間來運作，例如：<code>Sleep</code> 或是某些需要佔用大量時間才能完成的執行緒的話，您在終端機時會發現，您無法使用 <code>ctrl + c</code> 來取消這隻 Python 程式的執行，這種情形，就是一個簡單的執行緒阻塞情況！</p>
</blockquote>
<p><span style=" border: 0px;color: #fff;background: #f44336;border: 1px solid #f44336;border-radius: 4px;padding: 2px 5px;margin: 0 1px;">貼心小叮嚀！</span>如果您嚐試了下面的程式碼，最後不能<code>ctrl + c</code> 的話，請使用<code>ctrl + c</code> ， 之後 kill %1  就可以了，但前提是您沒有其他任務要執行！</p>
<p>舉個簡單阻塞情況的 Python 程式範例來說：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">import time</div><div class="line"></div><div class="line">def wait():</div><div class="line">	time.sleep(500)</div><div class="line"></div><div class="line">threads = []</div><div class="line"></div><div class="line">for i in range(0,5):</div><div class="line">	threads.append(threading.Thread(target = wait))</div><div class="line"></div><div class="line">for a in threads:</div><div class="line">	a.start()</div></pre></td></tr></table></figure></p>
<p>如果您看過 Python threading 的官方文件，你就會了解到這問題一定是 join() 或是  isDaemon()/setDaemon/daemon 的問題，了解了阻塞的情形之後，我們就來深入探討為什麼會造成阻塞的問題！</p>
<h3 id="簡單介紹阻塞發生的原因"><a href="#簡單介紹阻塞發生的原因" class="headerlink" title="簡單介紹阻塞發生的原因"></a>簡單介紹阻塞發生的原因</h3><ul>
<li>join() 的方法:  Thread 函式庫中的一個方法，可以將子執行緒，Join到主執行緒當中，對任何一個使用 join() 方法的執行緒呼叫來說，他會使主要的執行緒，等待所有子執行緒完成之後才退出！</li>
</ul>
<blockquote>
<p>關於前面提過的 Process，其實對於一個 Process 來說，可以把一個 Process 當成一個主執行緒，裡面的 Thread 只能算是子執行緒而已！</p>
</blockquote>
<ul>
<li>isDaemon()/setDaemon()/daemon的方法：這是一個類似開關的屬性，也是 Python 官方推薦的屬性，將所有子執行緒的該種屬性，設置為 True ，這個動作將會使得子執行緒隨著主執行緒的退出而退出，不會發生上述問題。（如果是False 的話，主執行緒會自顧自的退出，而子執行緒會繼續自己執行，直到子執行緒結束為止）</li>
</ul>
<blockquote>
<p>貼心小提醒，該屬性預設值為 False ，需要在質性續啟動前就定義！</p>
</blockquote>
<h3 id="問題分析"><a href="#問題分析" class="headerlink" title="問題分析"></a>問題分析</h3><p>說到這裡不知道各位看官有沒有發現一些端倪，或是有覺得有哪裡不太合理？在看完阻塞發生的原因之後，為何會出現執行緒阻塞的問題呢？其實這並不叫做阻塞，換個更貼切的說法，在預設的情況下，在主執行緒完成之後，子執行緒並不會退出（預設Daemon屬性為False），這個時候主執行緒已退出，沒有人可以接收 <code>ctrl + c</code> 的這道命令，子執行緒相當於沒有人管理，不知道要接收訊號，所以才沒有辦法停止子執行緒的運作唷！以上面的範例來說，如果您在整個主程式的最後加上 <code>time.sleep(500)</code> 就可以保證主執行緒一直存在，那麼如果您按下<code>ctrl + c</code> 自然而人就可以將訊號告訴個個執行緒，但因為子執行緒沒有設置 Daemon 屬性為 True ，所以子質性續還是會佔用著終端機！</p>
<blockquote>
<p>所以合理的推論，是不是使用前面提過的 join 方法可以解決？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">import time</div><div class="line"></div><div class="line">def wait():</div><div class="line">    time.sleep(500)</div><div class="line">    </div><div class="line">threads = []</div><div class="line">for i in range(0,5):</div><div class="line">    threads.append(threading.Thread(target=wait)</div><div class="line"></div><div class="line">for t in threads:</div><div class="line">    t.daemon = True</div><div class="line">    t.start()</div><div class="line"></div><div class="line">for t in threads:</div><div class="line">    t.join()</div></pre></td></tr></table></figure>
<p>您會發現雖然看起來很合理，但是！<br>人生中最討厭的就是這個但是！！！<br><code>ctrl + c</code>  還是不能使用 ＝口＝</p>
<p>為什麼 ？</p>
<p>原來是因為 join 的這個方法是預設把所有對主執行緒的輸入訊號都擋掉的！進而保證子執行緒成功被完整執行！所以雖然你成功的呼叫並且使用了 join（）、且設置了 Daemon 屬性，但是鍵盤的訊號還是無法到達主執行緒當中。</p>
<p>貼心小提醒，這種情況已經跟之前所說的主執行緒無法接收到訊號已經完全不同了！這個時候主要的執行緒才是真正被阻塞了，而之前的情形只是因為主執行緒已經退出而收不到訊號而已！所以就算加上 <code>time.sleep(500)</code> 讓主執行緒繼續活著管理子執行緒，<code>ctrl + c</code> 也已經失去功效了！</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="# 解决方法"></a># 解决方法</h3><p>對於上面兩個例子來說，總是像跟我一樣初學 Python 的新手會犯的錯誤，而且在對於python 這個優雅的語言來說，其實是一種非常不優雅的實作方式！簡直就是有著缺陷的土發煉鋼方法！十分的不推薦，所以其中一種我認為優雅的做法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line">import time</div><div class="line"></div><div class="line">def wait():</div><div class="line">    time.sleep(500)</div><div class="line"></div><div class="line">threads = []</div><div class="line">for i in range(0,5):</div><div class="line">    threads.append(threading.Thread(target=wait)</div><div class="line"></div><div class="line">for t in threads:</div><div class="line">    t.daemon = True</div><div class="line">    t.start()</div><div class="line"></div><div class="line">while threading.activeCount() &gt; 0:</div><div class="line">    time.sleep(1)</div></pre></td></tr></table></figure></p>
<p>這個方式是透過將 Daemon  這個屬性設置為 True，隨後每一秒檢查一次子執行緒的數目，以確保所有子執行緒都完整執行，這樣相當於手動時做了一個不會將鍵盤訊號阻擋在外的 join() !是不是既優雅又方便？</p>
<h2 id="獲取返回值-return"><a href="#獲取返回值（-Return-）" class="headerlink" title="獲取返回值（ Return ）"></a>獲取返回值（ Return ）</h2><p>其實這才是使用多執行緒最常遇見的問題，但是很遺憾的官方並沒有預設的方法可以獲得 Return 的值。目前有兩種方式可以達到這種效果：</p>
<h3 id="寫在-run-當中"><a href="#寫在-run-當中" class="headerlink" title="#寫在 run() 當中"></a>#寫在 run() 當中</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import threading</div><div class="line"></div><div class="line">class myThread(threading.Thread):</div><div class="line">    def __init__(self):</div><div class="line">        threading.Thread.__init__(self)</div><div class="line"></div><div class="line">   def run(self):</div><div class="line">        return 1</div><div class="line">t = myThread()</div><div class="line"></div><div class="line">result = t.run()</div><div class="line">print result</div></pre></td></tr></table></figure>
<p>但這種方法並不優雅，充其量只能說是勉強完成了我們的任務而已，也不夠嚴謹，但對於一般簡單的例子來說，這種方法已經足夠。</p>
<h3 id="採用佇列"><a href="#採用佇列" class="headerlink" title="# 採用佇列"></a># 採用佇列</h3><p>這才是目前最主流的獲取執行緒返回值的方法。使用 Queue 的函式庫創建佇列，用來儲存多個執行緒之間傳送的數據，在 Python 當中佇列是執行緒安全的，也就是說多個執行緒，同時存取同一個佇列也不會有衝突（當然多重存取資料庫又是另外一個故事了！）</p>
<p>Python 的佇列有三種進出的方式</p>
<ol>
<li>FIFO (先進先出)</li>
<li>FILO (先進後出)</li>
<li>優先佇列（由單獨的優先順序參數決定順序）</li>
</ol>
<p>舉例說明：</p>
<blockquote>
<p>貼心小提醒，關於本例子所舉的「 生產者–消費者」問題，是一個很經典的多執行緒處理時的問題，因篇幅關係，預知詳情請至 <a href="https://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98" target="_blank" rel="external">維基百科–生產者消費者問題</a> 查詢</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> Queue</div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 生產者執行緒</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, queue)</span>:</span></div><div class="line">        threading.Thread.__init__(self)</div><div class="line">        self.data = queue</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="comment"># 產生10個1~20 間的隨機數字放入佇列當中</span></div><div class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">            num = random.randint(<span class="number">1</span>,<span class="number">20</span>)</div><div class="line">            <span class="keyword">print</span> <span class="string">"original num"</span>, num</div><div class="line">            self.data.put(num)</div><div class="line">            time.sleep(<span class="number">1</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># 消費者執行緒</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, queue)</span>:</span></div><div class="line">        threading.Thread.__init__(self)</div><div class="line">        self.data = queue</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">while</span> self.data.qsize() &gt; <span class="number">0</span>:</div><div class="line">            num = self.data.get()</div><div class="line">            new_num = num * <span class="number">10</span> - <span class="number">1</span></div><div class="line">            <span class="keyword">print</span> <span class="string">'new num'</span>, new_num</div><div class="line">            time.sleep(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="comment"># 主程式</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></div><div class="line">    queue = Queue.Queue()</div><div class="line">    producer = Producer(queue)</div><div class="line">    consumer = Consumer(queue)</div><div class="line">    producer.daemon = <span class="keyword">True</span></div><div class="line">    consumer.daemon = <span class="keyword">True</span></div><div class="line">    producer.start()</div><div class="line">    time.sleep(<span class="number">0.5</span>)</div><div class="line">    consumer.start()</div><div class="line"></div><div class="line">    <span class="keyword">while</span> threading.activeCount() &gt; <span class="number">0</span>:</div><div class="line">        time.sleep(<span class="number">1</span>)</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</div><div class="line">    main()</div></pre></td></tr></table></figure>
<p>在這個範例當中，兩個執行緒通過一個佇列，來實作互相交換資料，同樣的方法也可以將一個執行緒當中的返回值給取出，是不是一舉兩得？</p>
<hr>
<h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><p>終於寫完了！執行緒真是一道天塹，邁過去的路上只能說是漫漫長路！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[[Linux] Sublime text 3編輯器轉職 Trace Code利器（基本篇）]]></title>
      <url>http://blog.30cm.net/2017/01/29/Linux-Sublime-text-3%E7%B7%A8%E8%BC%AF%E5%99%A8%E8%BD%89%E8%81%B7-Trace-Code%E5%88%A9%E5%99%A8-1/</url>
      <content type="html"><![CDATA[<blockquote>
<p><span style=" border: 0px;color: #fff;background: #f44336;border: 1px solid #f44336;border-radius: 4px;padding: 2px 5px;margin: 0 1px;">貼心小提醒</span>！網路上關於 Sublime Text 的教學真的很多，優秀的大大們也寫了很多深具質量的好教學，這篇其實只是小弟我的備忘錄而已 !</p>
</blockquote>
<hr>
<h3 id="引言"><a href="#＃引言" class="headerlink" title="＃引言"></a>＃引言</h3><p>小弟最近在追蹤 <code>CUPS</code> 的程式碼，原本一開始笨笨的，找一些 function 都要一個檔案一個檔案得開，工作效率實在是不敢恭維，經過高人指點，也看了<a href="https://docs.google.com/file/d/0B2jE5mgB1K4TblhMRmdnRUg2NFE/edit" target="_blank" rel="external">真男人，就該用VIM</a>  以及  <a href="http://stenlyho.blogspot.tw/2010/03/vim-trinity-source-explorer-tag-list.html" target="_blank" rel="external">史丹利部落</a> 後，深深地覺得 <del>VIM</del> 這位編輯器之神實在不是我的菜，所以決定還是用我最趁手的編輯器 <code>Sublime Text</code> 來實現這項功能，找了許久 ，終於實踐了Sublime Text 可以 Trace Code 了，接下來，我們就來看看是怎麼實現的吧 !</p>
<hr>
<h3 id="sublime-text3-打造一個編譯環境"><a href="#＃Sublime-Text3-打造一個編譯環境" class="headerlink" title="＃Sublime Text3 打造一個編譯環境"></a>＃Sublime Text3 打造一個編譯環境</h3><p>眾所周知 Sublime Text 是一款編輯器，原本是用來開發網頁用的，而且他是 <del>要錢的</del>，只是因為開發者真的很佛心，想要讓更多人可以使用，就開放無限免費試用！<span style=" border: 0px;color: #fff;background: #f44336;border: 1px solid #f44336;border-radius: 4px;padding: 2px 5px;margin: 0 1px;">請大家有閒錢一定要支持一下這位開發者</span>，偏題了！ 這款編輯器，除了很美之外，更有很多插件可以使用，而且對於習慣 VIM 的朋友來說，他也有 VIM 的操作模式可以選擇，這是我選擇這款編輯器作為寫程式工具的最大原因。</p>
<p>但是也因為他是圖形化介面的，在 Linux 環境下，寫完程式需要切換到<span style=" border: 0px;color: #41bf0c;background: #272329;    border: 1px solid #272329;border-radius: 4px;padding: 2px 5px;margin: 0 1px;">終端機</span>才可以編譯，稍嫌麻煩，偶爾操作會跟不上思維，所以就起了想要把編譯器放入的想法！</p>
<blockquote>
<p>偷偷告訴大家其實很簡單！他有內建的功能唷</p>
</blockquote>
<p>路徑是 Tools —&gt; Build System 您就可以選擇一些預設的編譯器了，接下來只要按快捷鍵 <code>control + b</code> 就會在下方出現編譯成功的字樣了！</p>
<p><img src="https://lh3.googleusercontent.com/-3uCyk8RThaE/WIyosj2Z1dI/AAAAAAAAADs/zT_j1ilTsEgnA4VO9TgtZLRx43jXrzRxwCLcB/s800/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2017-01-28+%25E4%25B8%258B%25E5%258D%258810.19.06.png" alt="enter image description here" title="螢幕快照 2017-01-28 下午10.19.06.png"></p>
<p>如果你有錯誤！也會顯示唷！</p>
<p><img src="https://lh3.googleusercontent.com/-YvcOl2FmVgU/WIypF3vhaQI/AAAAAAAAAD0/hAuB3XmOnYcaq5z2bMkPnb1y_QUtpkNfgCLcB/s800/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2017-01-28+%25E4%25B8%258B%25E5%258D%258810.21.42.png" alt="enter image description here" title="螢幕快照 2017-01-28 下午10.21.42.png"></p>
<p>是不是非常的方便？當然如果您想自己添加編譯器的話，也是非常可以的唷！<br>您可以依照系統的不同，修改終端機的參數，並且建立新的編譯系統<br>以 Ubuntu 為例，開啟 Sublime Text 的<br><code>Tools –&gt; Build System –&gt; New Build System</code> </p>
<p>然後貼入下面的代碼:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&#123;</div><div class="line">    &quot;cmd&quot;: [&quot;g++&quot;, &quot;$&#123;file&#125;&quot;, &quot;-o&quot;,&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;&quot;, &quot;&amp;&quot;, &quot;gnome-terminal&quot;,&quot;-x&quot;, &quot;bash&quot;, &quot;-c&quot;, &quot;g++ &apos;$&#123;file&#125;&apos; -o &apos;$&#123;file_path&#125;/$&#123;file_base_name&#125;&apos; &amp;&amp; &apos;$&#123;file_path&#125;/$&#123;file_base_name&#125;&apos; ;read -n1 -p &apos;press any key to continue.&apos;&quot;],</div><div class="line">    &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,</div><div class="line">    &quot;working_dir&quot;: &quot;$&#123;file_path&#125;&quot;,</div><div class="line">    &quot;selector&quot;: &quot;source.c, source.c++&quot;,</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然後儲存，並且取一個自己喜歡的名字<br>最後在 <code>Tools-&gt;Build System</code> 中選擇即可。<br>如果你貼上去出錯了，沒關係，請到 <a href="https://gist.github.com/Xuanwo/31ac95e82d446db37c2e" target="_blank" rel="external">這裏</a> 尋找答案！</p>
<hr>
<h3 id="安裝套件的開始"><a href="#＃安裝套件的開始" class="headerlink" title="＃安裝套件的開始"></a>＃安裝套件的開始</h3><p>首先你需要先安裝最重要的 Key ，如果沒有他你連套件都很難安裝的！就是先在 Sublime Text 中按下 <code>control</code>  + <code>shift</code>  + <code>p</code> 然後鍵入 Package Control: Install Package 就可以安裝套件控制的程式了，以後只要找到這個指令，就可以切換安裝套件的功能出來了喔！</p>
<hr>
<h3 id="安裝-ctags-工具"><a href="#＃安裝-Ctags-工具" class="headerlink" title="＃安裝 Ctags 工具"></a>＃安裝 Ctags 工具</h3><blockquote>
<p><span style=" border: 0px;color: #fff;background: #f44336;border: 1px solid #f44336;border-radius: 4px;padding: 2px 5px;margin: 0 1px;">貼心小提醒</span>！如果您已經傳統用 sudo apt-get install exuberant-ctags 安裝 ctags 工具並無法幫助你在  <del>Sublime Text</del> 裡面使用它唷！</p>
</blockquote>
<p>請照著以下步驟使用！</p>
<ol>
<li><code>control</code>  + <code>shift</code>  + <code>p</code> 然後鍵入 Package Control: Install Package</li>
</ol>
<p><img src="https://lh3.googleusercontent.com/-eO_XIQIwO1A/WIy0cW8BULI/AAAAAAAAAEU/os4vdi7tWW4j-mQyDeF2isJD8ovdRW11ACLcB/s800/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2017-01-28+%25E4%25B8%258B%25E5%258D%258811.04.23.png" alt="enter image description here" title="螢幕快照 2017-01-28 下午11.04.23.png"></p>
<p>2.鍵入 Ctags ，選擇 Ctags<br><img src="https://lh3.googleusercontent.com/-bJAJZJa5Vfk/WIy0shzDuQI/AAAAAAAAAEc/wVMocqhh5IIiG3NYRC3FYBf2iIn4zQ91wCLcB/s800/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2017-01-28+%25E4%25B8%258B%25E5%258D%258811.05.21.png" alt="enter image description here" title="螢幕快照 2017-01-28 下午11.05.21.png"></p>
<p>3.對資料夾 建立/更新 索引檔</p>
<p><img src="https://lh3.googleusercontent.com/-oaCpQ767-Wo/WIzEoqvTFrI/AAAAAAAAAE8/CRE2HoBP1lAVdebmBkSzEQMcW85q_vN2wCLcB/s800/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2017-01-28+%25E4%25B8%258B%25E5%258D%258811.07.25.png" alt="enter image description here" title="螢幕快照 2017-01-28 下午11.07.25.png"></p>
<p>4.巡覽！只要標籤你想要找的 Function 就可以在別的檔案中找到唷！（如果有的話）<br><img src="https://lh3.googleusercontent.com/-Rh9X4b7p9Y4/WIzE0hI18AI/AAAAAAAAAFE/6lSHUcMNttkGAr5N9b20HdYRjEhONSqCgCLcB/s800/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2017-01-28+%25E4%25B8%258B%25E5%258D%258811.07.34.png" alt="enter image description here" title="螢幕快照 2017-01-28 下午11.07.34.png"></p>
<hr>
<h3 id="取代-grep-的-cscope"><a href="#取代-Grep-的-Cscope-！" class="headerlink" title="# 取代 Grep 的 Cscope ！"></a># 取代 Grep 的 Cscope ！</h3><p>傳統我們使用 <code>grep -rn &#39;function_name&#39; ./</code>  指令來查找 哪隻程式會呼叫或使用到該變數或函式，但透過cscope 我們不需再用grep了!!!</p>
<p>透過Package Control:Install Package來安裝cscope後</p>
<p>1.建立以及更新索引</p>
<p><img src="https://lh3.googleusercontent.com/-wlF2D3IdgWQ/WIzH5vQob1I/AAAAAAAAAFc/F4ZI-oqhkeE7NjTaCC_dAAQ7_l3BbvppQCLcB/s800/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2017-01-29+%25E4%25B8%258A%25E5%258D%258812.28.47.png" alt="enter image description here" title="螢幕快照 2017-01-29 上午12.28.47.png"></p>
<p>2.開心查詢！</p>
<p><img src="https://lh3.googleusercontent.com/8_Ul8Okz89zp17dGNGRNE2iKx7r6DBwQa2HBy_5ZLoYYRPa_DeqLxXAsTRC42UmLqlfdgko=s800" alt="enter image description here" title="螢幕快照 2017-01-29 上午12.29.23.png"></p>
<blockquote>
<p><span style=" border: 0px;color: #fff;background: #f44336;border: 1px solid #f44336;border-radius: 4px;padding: 2px 5px;margin: 0 1px;">貼心小提醒</span>！使用Cscope的功能時，需按 Enter 鍵確定才會執行唷！</p>
</blockquote>
<hr>
<h3 id="常用套件"><a href="#＃常用套件" class="headerlink" title="＃常用套件"></a>＃常用套件</h3><p>1.<a href="https://packagecontrol.io/packages/HighlightWords" target="_blank" rel="external">HighlightWords</a></p>
<blockquote>
<p>用來來常駐 (持續性) 的標記某個單詞 (同時也會標記這整個文本裡所有出現的地方, 有助於 trace code),可透過 Control + Alt + H 來 Highlight 游標目前停留的字詞, 並對同樣的字詞再按一次快速鍵則取消標記, Control + Alt + U 則是取消全部的標記！</p>
</blockquote>
<p>2.<a href="https://packagecontrol.io/packages/BracketHighlighter" target="_blank" rel="external">BracketHighlighter</a></p>
<blockquote>
<p>Trace code 滿常需要的除了前面標記變數的功能以外, 另外也需要幫忙判斷括號從哪括到哪, 這Plugin就提供了這樣的的幫助。</p>
</blockquote>
<p>3.<a href="https://packagecontrol.io/packages/Block%20Cursor%20Everywhere" target="_blank" rel="external">Block Cursor Everywhere</a></p>
<blockquote>
<p>在文字編輯器內要尋找鍵盤的游標有時候也是種困擾, 這個 Plugin 可以幫忙在 Vim 指令 mode 下提供 方塊形 的鍵盤游標。</p>
</blockquote>
<p>4.AStyleFormatter</p>
<blockquote>
<p>Sublime Text 3下的C/C++程式碼整理工具，快捷鍵為 <code>Ctrl</code> + <code>Alt</code> + <code>F</code></p>
</blockquote>
<hr>
<h3 id="結語"><a href="#結語" class="headerlink" title="# 結語"></a># 結語</h3><p>工欲善其事，必先利其器！想要追蹤程式碼之前先把工具磨光，才可以發揮百分百的力量上場殺敵！</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[當個部落客！「 Hexo 」手把手教學 （下卷）]]></title>
      <url>http://blog.30cm.net/2017/01/21/%E7%95%B6%E5%80%8B%E9%83%A8%E8%90%BD%E5%AE%A2%EF%BC%81%E3%80%8C-Hexo-%E3%80%8D%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%AD%B8-%EF%BC%88%E4%B8%8B%E5%8D%B7%EF%BC%89-1/</url>
      <content type="html"><![CDATA[<!--toc-->
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><blockquote>
<p>本篇是 Hexo 的設定篇，內容包含了一些 Theme 的調整、網址綁定，如果有需要從頭搭建的朋友，也可以參考我的 <a href="http://blog.30cm.net/2017/01/21/%E7%95%B6%E5%80%8B%E9%83%A8%E8%90%BD%E5%AE%A2%EF%BC%81%E3%80%8C-Hexo-%E3%80%8D%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%AD%B8/">當個部落客！「 Hexo 」手把手教學 （上卷）</a>唷！</p>
</blockquote>
<p>那麼現在開始我們的主題吧！</p>
<h3 id="封印解除您的第一篇-hexo-文章"><a href="#封印解除！您的第一篇-Hexo-文章" class="headerlink" title="封印解除！您的第一篇 Hexo 文章"></a>封印解除！您的第一篇 Hexo 文章</h3><blockquote>
<p>從安裝到現在您不難發現 Hexo 都是使用指令安裝的，圖形化非常的少，雖然這樣對身為攻城獅的人來說，比較友善，但您可能想編編輯，邊預覽文章現在的狀況那就有點困難了，除了裝 hexo-admin-plug 之外還有沒有什麼更方便的選擇？或是我的網頁放在 Github Page 上，<del>沒辦法照片放爽爽欸！</del> 怎麼辦？接下來都將會為您解答喔！</p>
</blockquote>
<h3 id="安裝-hexo-admin"><a href="#安裝-Hexo-Admin" class="headerlink" title="安裝 Hexo Admin"></a>安裝 Hexo Admin</h3><p>首先，這個套件非常簡單只要輸入下列指令安裝就可以了！<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd yourblog</div><div class="line">npm install --save hexo-admin</div></pre></td></tr></table></figure></p>
<p>接著進入您部落格的主目錄下的 <code>_config.yml</code> 檔案輸入如下設定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"># Admin</div><div class="line">admin:</div><div class="line">    name: 您的帳號</div><div class="line">    password: 您的密碼</div><div class="line">    secret: hey hexo</div><div class="line">    expire: 60*1</div><div class="line">    # cors: http://localhost:3000</div></pre></td></tr></table></figure>
<p>最後重新產生靜態檔案以及啟動在本機的 Hexo Server就可以完成了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">hexo g</div><div class="line">hexo s</div></pre></td></tr></table></figure>
<p>這樣就完成了，趕快來試試看吧 !<br>在瀏覽器上輸入 localhost:4000/admin 就可以開始編輯您的文章了喔！</p>
<p><img src="https://lh3.googleusercontent.com/-_gFG0Hh1v3c/WINha9vZXpI/AAAAAAAAACY/9PoN1-O2ywAMwK4ANvFnBk_UD4hAOoLwwCLcB/s800/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2017-01-21+%25E4%25B8%258B%25E5%258D%25889.24.21.png" alt="enter image description here" title="螢幕快照 2017-01-21 下午9.24.21.png"></p>
<p>如果嫌版面不夠好看的話推薦一個好用的 Markdown 編輯器 ，<a href="https://stackedit.io" target="_blank" rel="external"> Stackedit </a> 這款好用的編輯器，因為可以跟 Google Drive 、Drop Box等等做結合，圖片可以通過它直接上傳！非常方便！！</p>
<p><img src="https://lh3.googleusercontent.com/-Q97GDoE-HFo/WINnNLlD0bI/AAAAAAAAAC4/Xaw2BerSb00rLhw9NLCiki4-ULR5OaQ9gCLcB/s800/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2017-01-21+%25E4%25B8%258B%25E5%258D%25889.46.19.png" alt="enter image description here" title="螢幕快照 2017-01-21 下午9.46.19.png"></p>
<p>他有很多功能，例如上圖片的只要點擊上方的圖片按鈕，之後登入您的 google 帳號，就可以在你 Google上直接上傳照片並插入了！很方便吧！寫完文章之後，一定要放到github上才算完成唷，因為編輯文章是在本地端編輯的，所以您建立的資料夾一定不能刪除喔，不然就只能哭哭了！！</p>
<p>上傳的指令如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo clean (清除快取)</div><div class="line">hexo g (產生靜態檔案)</div><div class="line">hexo d （在 Github 上顯示！）</div></pre></td></tr></table></figure></p>
<p>這樣就完成了！</p>
<h3 id="theme主題更換教學"><a href="#Theme主題更換教學" class="headerlink" title="Theme主題更換教學"></a>Theme主題更換教學</h3><p>這裏只跟大家報告，如何更換主題，至於主題如何設定，每一個主題都有不同的規範唷！而我的主題官方更是提供詳細的解答給大家，教大家一步一步教學，我把網址提供給大家！<a href="https://material.viosey.com/" target="_blank" rel="external">Material ! </a></p>
<p>更改主題其實很簡單，進入您部落格的主目錄下的 <code>_config.yml</code> 檔案找到如下設定並更改就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">theme: material</div></pre></td></tr></table></figure>
<h3 id="綁定網址"><a href="#綁定網址" class="headerlink" title="綁定網址"></a>綁定網址</h3><p>在這個資訊爆炸的年代，各家部落格百家爭鳴，有一個好記得網址，是非常重要的！如果您覺得 XXXX.github.io的網址不能表示您個人的品牌的話就去買一個網址吧，首先您要在您的 DNS 的供應商，通常是買網址的地方設定一個 CNAME設定好了之後，要在 yourname/source 下新增一個檔案名稱是 CNAME  裡面新增你的網址就可以了！</p>
<p><img src="https://lh3.googleusercontent.com/-5X4mVZYxPlE/WINtP1LPthI/AAAAAAAAADY/5JlFeQaMAJ0awTylZprFCER5sX3H9GeVgCLcB/s800/1.jpg" alt="enter image description here" title="1.jpg"></p>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>這樣建立一個部落格，雖然建立的初期不像其他的部落格一樣好上手，甚至需要一段時間來熟悉與瞭解，但建立完成之後，除了免費這個好處之外，更擁有google的空間，對個人的普通入門級玩家來說，技術含量較把本部落格推到 vps 或其他雲端主機如 Amazon 來得更低，且Github上的空間穩定不會像 Heroku 或是 OpenShift 的免費用戶一樣，一段時間不使用就會關機，重新連上時要等一小段時間讓他開機！又不用擔心主機管理的問題！！真是好處多多</p>
<blockquote>
<p>大家快一點一起來跟我建立部落格，隨手筆記，分享心得吧！</p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[當個部落客！「 Hexo 」手把手教學 （上卷）]]></title>
      <url>http://blog.30cm.net/2017/01/21/%E7%95%B6%E5%80%8B%E9%83%A8%E8%90%BD%E5%AE%A2%EF%BC%81%E3%80%8C-Hexo-%E3%80%8D%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E5%AD%B8/</url>
      <content type="html"><![CDATA[<!-- toc -->
<ul>
<li><a href="#引言">引言</a></li>
<li><a href="#起手式-使用github-page-搭建-hexo">起手式 [ 使用Github Page 搭建 Hexo ]</a></li>
<li><a href="#建立-github-page-環境">建立 Github Page 環境</a></li>
<li><a href="#建立-hexo-環境">建立 Hexo 環境</a></li>
</ul>
<!-- tocstop -->
<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>研究了許久，終於發現為何各位<span style=" border: 0px;color: #fff;background: #f44336;    border: 1px solid #f44336;
    border-radius: 4px;
    padding: 2px 5px;
    margin: 0 1px;">30cm</span>、<span style=" border: 0px;color: #fff;background: #f44336;    border: 1px solid #f44336;
    border-radius: 4px;
    padding: 2px 5px;
    margin: 0 1px;">E cup</span>的程序猿、攻城獅大大們要自己寫個人網站呢？全部都是因為<del>這樣就可以走在時尚尖端</del>，為了有個地方能夠「分享生活中的觀察」以及「記錄個人所學及經歷」。所以需要類似部落格功能的網站，身為專業的<span style=" border: 0px;color: #41bf0c;background: #272329;    border: 1px solid #272329;
    border-radius: 4px;
    padding: 2px 5px;
    margin: 0 1px;">攻城獅</span>，一定要潮到出水的自己建立一個才行，講了這麼多，現在要回到正題：</p>
<h3 id="起手式-使用github-page-搭建-hexo"><a href="#起手式-使用Github-Page-搭建-Hexo" class="headerlink" title="起手式 [ 使用Github Page 搭建 Hexo ]"></a>起手式 [ 使用Github Page 搭建 Hexo ]</h3><p><img src="https://lh3.googleusercontent.com/-nBJskXQv49w/WIJEgkM08QI/AAAAAAAAABA/vliEuVfEpV01qCnJaYOVEW7pTh3-m95YACLcB/s800/5bb7J7NT+%25281%2529.png" alt="enter image description here" title="5bb7J7NT &#40;1&#41;.png"></p>
<p>首先起手式很簡單，你必須要先有一個可以放網站的空間！總不好部落格<del>常常出事</del>，這樣就不能朝一個專業的寫手邁進了！你說是吧。</p>
<p>所以為了要讓我們可以專心寫個網站而不讓 <strong>煩人的主機問題困擾我們</strong>，我們先從最簡單又免費的<span style=" border: 0px;color: #000;background: #f4dd36;    border: 1px solid #f4dd36;
    border-radius: 4px;
    padding: 2px 5px;
    margin: 0 1px;">Github Page</span> 開始用起吧！</p>
<p>如果你本身懂一點資訊的話，可以直接參考原始資料來實作：</p>
<ol>
<li><a href="https://hexo.io/zh-tw/" target="_blank" rel="external">Hexo 官方網站</a></li>
<li><a href="https://hexo.io/themes/" target="_blank" rel="external">選一個樣式吧！ Hexo 官方主題樣式 </a></li>
<li><a href="https://oawan.me/2016/easy-hexo-easy-blog/" target="_blank" rel="external">新樂街的三角窗  [Hexo] 快速上手 Hexo 網誌框架</a></li>
<li><a href="https://github.com/viosey/hexo-theme-material" target="_blank" rel="external">如果你喜歡我的主題的話！ 就決定是你了Material</a></li>
</ol>
<p>懶得想的朋友請，請服用以下懶人包，手把手教你搭建個人網站唷！</p>
<h3 id="建立-github-page-環境"><a href="#建立-Github-Page-環境" class="headerlink" title="建立 Github Page 環境"></a>建立 Github Page 環境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Step 1 註冊一個 Github 帳號</div></pre></td></tr></table></figure>
<p><del>怎麼註冊在這邊就不再贅述</del>   請右轉  <a href="https://github.com/" target="_blank" rel="external">Github</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Step 2 搞定 Github Page !</div></pre></td></tr></table></figure>
<p>靜態網頁好夥伴 Github Pages ！ 它是可以給用戶編寫、託管在 Github 上的靜態網頁 。在申請玩 Github 帳號之後，可以看正中間有一個大大的 Start a Project<br>給他大力按下去就對了！<br>如圖：<br><img src="https://lh3.googleusercontent.com/-HUoYkHbeykE/WIJJoGs_lCI/AAAAAAAAABc/877qo4Al7nMwIh37Q7KG8SDVDjD2RsSEgCLcB/s800/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2017-01-21+%25E4%25B8%258A%25E5%258D%25881.20.25.png" alt="enter image description here" title="螢幕快照 2017-01-21 上午1.20.25.png"></p>
<p>將專案名稱取名為 username.github.io 並按下最下方的 Create repository</p>
<p>P.S  本文章 yourname 或 username 指的就是你的 Github 帳號唷！</p>
<p><img src="https://lh3.googleusercontent.com/-Ls_WpPUorxs/WIJJ3SkahKI/AAAAAAAAABk/AeRVegb-txwcErQal213Hzs3r3NE8nEmACLcB/s800/%25E8%259E%25A2%25E5%25B9%2595%25E5%25BF%25AB%25E7%2585%25A7+2017-01-21+%25E4%25B8%258A%25E5%258D%25881.20.30.png" alt="enter image description here" title="螢幕快照 2017-01-21 上午1.20.30.png"></p>
<p>恭喜你建立好 Github Pages 的專案了！<br>現在就馬上點進 <a href="http://username.github.io" target="_blank" rel="external">http://username.github.io</a> ，你會發現 <del>有東西</del> 才怪！<br>哦原來是我還沒把東西放上來呀！沒錯 Github Pages的預先設置就是這麼簡單 ，接下來要部署 Hexo上來了！部署完之後才會有東西唷！</p>
<h3 id="建立-hexo-環境"><a href="#建立-Hexo-環境" class="headerlink" title="建立 Hexo 環境"></a>建立 Hexo 環境</h3><p>這裏有一個前提，我是用 Mac 電腦，如果是 <del>微軟</del> 的話，出口在直走右轉唷！關鍵字是 windows 安装 hexo，好接下來開始吧！</p>
<p>而 Hexo 需要安裝以下系統環境來支援：</p>
<p>1.<a href="https://nodejs.org/en/" target="_blank" rel="external">Node.js</a><br>2.<a href="https://git-scm.com/" target="_blank" rel="external">Git</a><br>3.<a href="https://itunes.apple.com/hk/app/xcode/id497799835?l=zh&amp;mt=12" target="_blank" rel="external">Xcode ( Mac用戶必須安裝 )</a></p>
<p>安裝好了之後我們可以開啟我們的終端機，並輸入以下指令安裝 Hexo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ npm install -g hexo-cli</div></pre></td></tr></table></figure>
<p>安裝完之後我們便可以來建立網站了！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Step 3 開啟終端機依序使用以下指令 :</div><div class="line"></div><div class="line">$ hexo init yourname ( 初始化新的 Hexo )</div><div class="line">$ cd yourname  ( 進入您剛剛建立的 Hexo 資料夾當中 )</div><div class="line">$ npm install （ 安裝 Hexo )</div></pre></td></tr></table></figure>
<blockquote>
<p>yourname 就是指在電腦裡的檔案名稱，可以隨意取，例如「myhexoblog」</p>
</blockquote>
<p>這樣就完成安裝了！</p>
<p>接下來就要開始設定 Hexo 讓你的網站可以個人化，符合建立自己網站的宗旨唷！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Step 4 設定 Hexo</div></pre></td></tr></table></figure>
<p>進入您 Hexo 主目錄下之後，先找到_config.yml 這個檔案！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">title: 不為繁華易匠心 (輸入您的標題)</div><div class="line">subtitle: 匠心，是傾注於作品之中的精神、情感、乃至魂魄。 （輸入您的至理名言）</div><div class="line">description:(輸入您的網站描述)</div><div class="line">author: 王性驊 （輸入您的姓名）</div><div class="line">language: zh-TW （輸入您所使用的語言）</div><div class="line">timezone: (留空可以使用系統時間！)</div></pre></td></tr></table></figure>
<p>這樣就第一步完成您的設定了！<br>接下來，要找到上傳至 github 的設定，使用「搜尋」找出 deploy:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">   type: git</div><div class="line">   repo: https://github.com/username/username.github.io.git</div><div class="line">   branch: master</div></pre></td></tr></table></figure>
<p>username 就是指你自己的github帳號，記得改對，然後按存檔。</p>
<p>然後回到你的終端機，先進入 yourname 資料夾<br>並依序輸入以下指令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ hexo clean (清除快取)</div><div class="line">$ hexo g （建立靜態檔案）</div><div class="line">$ hexo d （在 Github Page 上顯示）</div></pre></td></tr></table></figure>
<p>這三個指令就是幫我們把網站自動生成並發佈到 <a href="http://username.github.io" target="_blank" rel="external">http://username.github.io</a> 上的指令，完成後應該就可以打開瀏覽器看看自己網站發布成功的樣子囉！</p>
<blockquote>
<p>消化一下吧！欲知更詳細的教學，請見下回分曉！</p>
</blockquote>
<p>預告一下：<br>下回！建立後端編輯環境，以及安裝主題還有討論區！</p>
<p>敬請期待～～</p>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[使用網頁介面來控制 Arduino UNO]]></title>
      <url>http://blog.30cm.net/2016/06/16/%E4%BD%BF%E7%94%A8%E7%B6%B2%E9%A0%81%E4%BB%8B%E9%9D%A2%E4%BE%86%E6%8E%A7%E5%88%B6-Arduino-UNO/</url>
      <content type="html"><![CDATA[<h1 id="環境架設"><a href="#環境架設" class="headerlink" title="環境架設"></a>環境架設</h1><blockquote>
<p>各位看官，大家好，基於小弟懶惰，想要躺在床上就可以控制家裡的電燈之類的家電，可以簡單控制的方法有很多種，我挑了一種對我來說最最省力的方法</p>
</blockquote>
<p>使用Python + Web 控制 Arduino<br>這種經濟實惠的方法怎麼可以錯過？<br>但是在開始之前，要先準備一下環境</p>
<p>以下是要準備的環境</p>
<blockquote>
<p>OS : CentOS 7 (如果你使用Windows 系列的話，請恕小弟無能XDD)<br>IDE : Arduino 1.6.9<br>Python 版本 ： 2.7.1<br>Python 套件 ： pyfirmata, pymysql,<br>應用程式：Apache2 , PHP , MariaDB , phpMyAdmin</p>
</blockquote>
<p>Step 1. 安裝網頁伺服器<br>因為安裝網頁伺服器的在我的上一篇部落格已經講過了，詳細請參考我的大神學長寫的部落格 安裝網頁伺服器.</p>
<p>Step2. 安裝 Arduino IDE<br>首先到 Arduino 官網下載最新版的 IDE</p>
<p>接著使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tar -vxf arduino-1.6.9-linux64.tgz</div></pre></td></tr></table></figure>
<p>這條指令解壓縮我們剛剛下載的安裝檔案，接著切換到root使用者或者。</p>
<p>使用下面這條指令將解壓縮後的文件移動到opt資料夾底下（因為一般Linux軟體都會安裝在 opt底下）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mv arduino-1.6.9 /opt/</div></pre></td></tr></table></figure>
<p>進入 /opt/arduino-1.6.9 的資料夾</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cd /opt/arduino-1.6.9</div></pre></td></tr></table></figure>
<p>執行arduino</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./arduino</div></pre></td></tr></table></figure>
<p>Step 3. 安裝Python 套件<br>Python 連線資料庫的套件 pymysql</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install pymysql</div></pre></td></tr></table></figure>
<p>Python 連線Arduino的套件 pyfirmata</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install pyfirmata</div></pre></td></tr></table></figure>
<h1 id="架構"><a href="#架構" class="headerlink" title="架構"></a>架構</h1><p>Arduino &lt;——&gt;  Python  &lt;—–&gt;  網路  &lt;——–&gt;  Server </p>
<p>如果想要使用 Python 與 Arduino 溝通首先要有一個類似 socket 的概念。<br>用 Arduino 的 StandardFirmata這支程式，讓我們可以盡情的不管底層，只要直接寫python 的程式碼就可以了，再使用 Python 與 Server 溝通後把資料存到資料庫就可以完美解決，而且溝通是雙向的， Server 也可以透過Python 命令 Arduino 做事。</p>
<p>接線圖明日補上<br>程式碼紀錄<br>主要是利用網路來控制繼電器讓電燈可以開登或關燈</p>
<p>python部分</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#! /usr/bin/env python</span></div><div class="line"><span class="keyword">from</span> pyfirmata <span class="keyword">import</span> Arduino , util ＃引入socket  </div><div class="line"><span class="keyword">import</span> time  </div><div class="line"><span class="keyword">import</span> pymysql.cursors  <span class="comment">#引入連接資料庫程式</span></div><div class="line"></div><div class="line">＃連接資料庫</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_status</span><span class="params">()</span>:</span>  </div><div class="line">    connection = pymysql.connect(host=<span class="string">'localhost'</span>,</div><div class="line">                             user=<span class="string">'帳號'</span>,</div><div class="line">                             password=<span class="string">'密碼'</span>,</div><div class="line">                             db=<span class="string">'資料庫名稱'</span>,</div><div class="line">                             charset=<span class="string">'編碼'</span>,</div><div class="line">                             cursorclass=pymysql.cursors.DictCursor)</div><div class="line">    <span class="keyword">try</span>:</div><div class="line">        <span class="keyword">with</span> connection.cursor() <span class="keyword">as</span> cursor:</div><div class="line">            <span class="comment"># Read a single record</span></div><div class="line">            sql = <span class="string">"SELECT `status` FROM `sencer` WHERE `name`=%s"</span></div><div class="line">            cursor.execute(sql, (<span class="string">'blink'</span>))</div><div class="line">            result = cursor.fetchone()</div><div class="line">            <span class="keyword">return</span> (result[<span class="string">'status'</span>])</div><div class="line">    <span class="keyword">finally</span>:</div><div class="line">        connection.close()</div><div class="line"></div><div class="line"></div><div class="line">PORT = <span class="string">'/dev/ttyACM0'</span>  </div><div class="line">board = Arduino(PORT)  </div><div class="line">it = util.Iterator(board)  </div><div class="line">it.start()  </div><div class="line">board.analog[<span class="number">0</span>].enable_reporting()</div><div class="line"></div><div class="line"><span class="keyword">while</span> <span class="number">1</span>:  </div><div class="line">    <span class="keyword">if</span> check_status() ==<span class="number">1</span>:</div><div class="line">        board.digital[<span class="number">13</span>].write(check_status())</div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        tmp=board.analog[<span class="number">0</span>].read()</div><div class="line">        <span class="keyword">print</span> tmp</div><div class="line">        <span class="keyword">if</span> tmp &gt; <span class="number">0.5</span> :</div><div class="line">            board.digital[<span class="number">13</span>].write(<span class="number">1</span>)</div><div class="line">            time123 = time.strftime(<span class="string">"%H:%M:%S"</span>)</div><div class="line">            connection = pymysql.connect(host=<span class="string">'localhost'</span>,</div><div class="line">                             user=<span class="string">'帳號'</span>,</div><div class="line">                             password=<span class="string">'密碼'</span>,</div><div class="line">                             db=<span class="string">'資料庫名稱'</span>,</div><div class="line">                             charset=<span class="string">'編碼'</span>,</div><div class="line">                             cursorclass=pymysql.cursors.DictCursor)</div><div class="line">            <span class="keyword">try</span>:</div><div class="line">                <span class="keyword">with</span> connection.cursor() <span class="keyword">as</span> cursor:</div><div class="line">                    <span class="comment"># Read a single record</span></div><div class="line">                    sql = <span class="string">"INSERT INTO `home`(`time`) VALUES (%s)"</span></div><div class="line">                    cursor.execute(sql, (time123))</div><div class="line">                    connection.commit()</div><div class="line"></div><div class="line">            <span class="keyword">finally</span>:</div><div class="line">                connection.close()</div><div class="line"></div><div class="line">            time.sleep(<span class="number">5</span>)</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            board.digital[<span class="number">13</span>].write(<span class="number">0</span>)</div><div class="line">        time.sleep(<span class="number">1</span>)</div></pre></td></tr></table></figure>]]></content>
    </entry>
    
  
  
</search>
